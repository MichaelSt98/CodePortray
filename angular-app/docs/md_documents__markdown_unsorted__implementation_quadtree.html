<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>CodePortray</title>
	<base href="/">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!--
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	-->
	<meta name="generator" content="Doxygen 1.9.3"/>
	<title>milupHPC: Efficient implementation of a Quadtree (for 2D collision detection)</title>
	<title>Efficient implementation of a Quadtree (for 2D collision detection)</title>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Alata&amp;display=swap" rel="stylesheet">
	<link rel="stylesheet" href="components/side-nav/styles.css">
	<link rel="stylesheet" href="components/hamburger/styles.css">
	<link rel="stylesheet" href="components/header/styles.css">
	<link rel="stylesheet" href="components/icons/styles.css">
	<link rel="stylesheet" href="components/dialog/styles.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
	<link href="doxygen-custom.css" rel="stylesheet" type="text/css" />
</head>
<body>
	<custom-header class="custom-header-class">
		<custom-hamburger menu onclick="toggle()"></custom-hamburger>
		<div shortcuts>
			<a href="https://www.google.com"><custom-icon icon="facebook" color="white" background="#3B5998"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="twitter" color="white" background="#55ACEE"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="youtube" color="white" background="#DB0000"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="linkedin" color="white" background="#3B67BE"></custom-icon></a>
			<!--<a href="https://www.google.com"><custom-icon icon="share-alt" color="white" background="darkgrey"></custom-icon></a>-->
			<custom-dialog window-width="600px" window-height="400px">
				<div open><custom-icon icon="share-alt" color="white" background="darkgrey"></custom-icon></div>
				<div>test 1</div>
				<div>test 2</div>
				<div>test 3</div>
				<div>test 4</div>
			</custom-dialog>
			<a href="https://www.google.com"><custom-icon icon="github" color="white" background="#2A2D32"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="university" color="white" background="#8D2439"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="wikipedia-w" color="black" background="lightgrey"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="slack" color="white" background="#421B4B"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="home" color="white" background="black"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="cogs" color="white" background="black"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="bars" color="white" background="black"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="code" color="white" background="black"></custom-icon></a>
			<a href="https://www.google.com"><custom-icon icon="terminal" color="white" background="black"></custom-icon></a>
		</div>
	</custom-header>
	<!--
	<custom-side-nav id="side-nav" nav-width="300">
		<custom-icon url="https://www.google.com" icon="code" color="white" background="black"></custom-icon>
		<div>test</div>
	</custom-side-nav>
	-->
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				milupHPC documentation
			</span>
		</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Efficient implementation of a Quadtree (for 2D collision detection) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a href="https://stackoverflow.com/questions/41946007/efficient-and-well-explained-implementation-of-a-quadtree-for-2d-collision-det">Stackoverflow: Efficient implementation of Quadtrees (for 2D collision detection)</a></p>
<h1><a class="anchor" id="autotoc_md163"></a>
Other possibility (than using Quadtrees)</h1>
<p >Using a <b>Grid hierarchy</b>, like</p>
<ul>
<li>a coarse grid for the world</li>
<li>a finer grid for a region</li>
<li>an even finer grid for a sub-region</li>
</ul>
<p >meaning 3 fixed levels of dense grids (no trees involved), with row-based optimizations so that a row withoug entities will be deallocated and turn into a null pointer.</p>
<h1><a class="anchor" id="autotoc_md164"></a>
Fundamentals of Quadtrees</h1>
<p ><b>Quadtrees are non-fixed resolutin grids, they adapt the resolution based on some criteria, while subdiving/splitting into 4 child cells to increase resolution.</b></p>
<h1><a class="anchor" id="autotoc_md165"></a>
Implemenation in C</h1>
<p >See <a href="https://github.com/Antymon/quadtree">GitHub: quadtree</a></p>
<h1><a class="anchor" id="autotoc_md166"></a>
Possible improvements regarding Implementations of Quadtrees</h1>
<h2><a class="anchor" id="autotoc_md167"></a>
Node representation</h2>
<div class="fragment"><div class="line"><span class="comment">// Represents a node in the quadtree.</span></div>
<div class="line"><span class="keyword">struct </span>QuadNode</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Points to the first child if this node is a branch or the first</span></div>
<div class="line">    <span class="comment">// element if this node is a leaf.</span></div>
<div class="line">    int32_t first_child;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores the number of elements in the leaf or -1 if it this node is</span></div>
<div class="line">    <span class="comment">// not a leaf.</span></div>
<div class="line">    int32_t count;</div>
<div class="line">};</div>
</div><!-- fragment --><p ><b>Possible improvement</b>: Memory reduction</p>
<ul>
<li><b>reduce the memory size</b> to a reasonable small amount</li>
<li><b>no bounding boxes/rectangles</b> (AABBs) stored within the node representation, compute them on the fly<ul>
<li>just store them <b>once in the root</b></li>
<li>seems to be more expensive to be computed on the fly, but reducing memory usage of the nodes can proportianlly reduce cache misses when traversing the tree, which tend to be more significant</li>
<li>not reasonable for data structures that don't split evenly like Kd-trees and BVHs</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md168"></a>
Traversel</h2>
<p >Traversel looks like</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> QuadNodeList find_leaves(<span class="keyword">const</span> Quadtree&amp; <a class="code hl_variable" href="namespace_profiler_ids_1_1_time.html#a6bc176ffe75049b4b899b6a019bf15e9">tree</a>, <span class="keyword">const</span> QuadNodeData&amp; root, <span class="keyword">const</span> <span class="keywordtype">int</span> rect[4])</div>
<div class="line">{</div>
<div class="line">    QuadNodeList leaves, to_process;</div>
<div class="line">    to_process.push_back(root);</div>
<div class="line">    <span class="keywordflow">while</span> (to_process.size() &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> QuadNodeData nd = to_process.pop_back();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If this node is a leaf, insert it to the list.</span></div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_variable" href="namespace_profiler_ids_1_1_time.html#a6bc176ffe75049b4b899b6a019bf15e9">tree</a>.nodes[nd.index].count != -1)</div>
<div class="line">            leaves.push_back(nd);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Otherwise push the children that intersect the rectangle.</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span> mx = nd.crect[0], my = nd.crect[1];</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span> hx = nd.crect[2] &gt;&gt; 1, hy = nd.crect[3] &gt;&gt; 1;</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span> fc = <a class="code hl_variable" href="namespace_profiler_ids_1_1_time.html#a6bc176ffe75049b4b899b6a019bf15e9">tree</a>.nodes[nd.index].first_child;</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span> l = mx-hx, t = my-hx, r = mx+hx, b = my+hy;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (rect[1] &lt;= my)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (rect[0] &lt;= mx)</div>
<div class="line">                    to_process.push_back(child_data(l,t, hx, hy, fc+0, nd.depth+1));</div>
<div class="line">                <span class="keywordflow">if</span> (rect[2] &gt; mx)</div>
<div class="line">                    to_process.push_back(child_data(r,t, hx, hy, fc+1, nd.depth+1));</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (rect[3] &gt; my)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">if</span> (rect[0] &lt;= mx)</div>
<div class="line">                    to_process.push_back(child_data(l,b, hx, hy, fc+2, nd.depth+1));</div>
<div class="line">                <span class="keywordflow">if</span> (rect[2] &gt; mx)</div>
<div class="line">                    to_process.push_back(child_data(r,b, hx, hy, fc+3, nd.depth+1));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> leaves;</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_profiler_ids_1_1_time_html_a6bc176ffe75049b4b899b6a019bf15e9"><div class="ttname"><a href="namespace_profiler_ids_1_1_time.html#a6bc176ffe75049b4b899b6a019bf15e9">ProfilerIds::Time::tree</a></div><div class="ttdeci">const char *const tree</div><div class="ttdef"><b>Definition:</b> <a href="h5profiler_8h_source.html#l00045">h5profiler.h:45</a></div></div>
</div><!-- fragment --><p ><b>Possible improvement</b>: Floating-Point</p>
<ul>
<li>Do not use floating-point (for spatial indexes, ...)</li>
<li>Even use integers for floating-point inputs</li>
</ul>
<h2><a class="anchor" id="autotoc_md169"></a>
Contiguous children</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>QuadNode</div>
<div class="line">{</div>
<div class="line">    int32_t first_child;</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p ><b>Possible improvement</b>: Contiguosity</p>
<ul>
<li>No need to store an array of children, because all 4 children are contiguous<ul>
<li>reduces cache misses on traversal</li>
<li>shrinks nodes (further reduces cache misses)</li>
<li><b>consequently</b>: splitting a parent means allocating for 4 children, even if some of the children are empty<ul>
<li>trade-off is worth it (in respect to performance)</li>
<li>deallocating children means deallocating <b>all 4 children at a time</b> using an indexed free list<ul>
<li>consequently usually no heap allocations or deallocations during the simulation <br  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">first_child+0 = index to 1st child (TL)</div>
<div class="line">first_child+1 = index to 2nd child (TR)</div>
<div class="line">first_child+2 = index to 3nd child (BL)</div>
<div class="line">first_child+3 = index to 4th child (BR)</div>
</div><!-- fragment --><p ><img src="Images/DeallocateChildren.png" alt="Deallocation of children" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md170"></a>
Deferred cleaning</h2>
<p ><b>Possible improvement:</b> deferred cleanup</p>
<ul>
<li>Don't update the quadtree's structure right away, just traverse to the child node(s) to be removed and remove the element and don't bother to do more even if the leaves become empty<ul>
<li>unnecesarily removing children only to add them right back when another element moves into that quadrant is avoided</li>
</ul>
</li>
<li>The cleanup method never removes the root</li>
</ul>
<p >Implementation looks like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Quadtree::cleanup()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Only process the root if it&#39;s not a leaf.</span></div>
<div class="line">    SmallList&lt;int&gt; to_process;</div>
<div class="line">    <span class="keywordflow">if</span> (nodes[0].count == -1)</div>
<div class="line">        to_process.push_back(0);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (to_process.size() &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> node_index = to_process.pop_back();</div>
<div class="line">        QuadNode&amp; node = nodes[node_index];</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop through the children.</span></div>
<div class="line">        <span class="keywordtype">int</span> num_empty_leaves = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 4; ++j)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">int</span> child_index = node.first_child + j;</div>
<div class="line">            <span class="keyword">const</span> QuadNode&amp; child = nodes[child_index];</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Increment empty leaf count if the child is an empty </span></div>
<div class="line">            <span class="comment">// leaf. Otherwise if the child is a branch, add it to</span></div>
<div class="line">            <span class="comment">// the stack to be processed in the next iteration.</span></div>
<div class="line">            <span class="keywordflow">if</span> (child.count == 0)</div>
<div class="line">                ++num_empty_leaves;</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (child.count == -1)</div>
<div class="line">                to_process.push_back(child_index);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If all the children were empty leaves, remove them and </span></div>
<div class="line">        <span class="comment">// make this node the new empty leaf.</span></div>
<div class="line">        <span class="keywordflow">if</span> (num_empty_leaves == 4)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Push all 4 children to the free list.</span></div>
<div class="line">            nodes[node.first_child].first_child = free_node;</div>
<div class="line">            free_node = node.first_child;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Make this node the new empty leaf.</span></div>
<div class="line">            node.first_child = -1;</div>
<div class="line">            node.count = 0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >which is called at the end of every frame, when removing all agents/particles.</p>
<h2><a class="anchor" id="autotoc_md171"></a>
Moving elements</h2>
<p >Straightforward:</p>
<ul>
<li>remove element</li>
<li>move element</li>
<li>reinsert to quadtree</li>
</ul>
<h2><a class="anchor" id="autotoc_md172"></a>
Singly-Linked Index Lists for Elements</h2>
<p ><b>Possible improvement:</b> Singly-linked index lists for elements</p>
<ul>
<li>transfer elements from split parents to new leaves by just changing a few integers</li>
</ul>
<p >Use the representation:</p>
<div class="fragment"><div class="line"><span class="comment">// Represents an element in the quadtree.</span></div>
<div class="line"><span class="keyword">struct </span>QuadElt</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stores the ID for the element (can be used to</span></div>
<div class="line">    <span class="comment">// refer to external data).</span></div>
<div class="line">    <span class="keywordtype">int</span> id;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores the rectangle for the element.</span></div>
<div class="line">    <span class="keywordtype">int</span> x1, y1, x2, y2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Represents an element node in the quadtree.</span></div>
<div class="line"><span class="keyword">struct </span>QuadEltNode</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Points to the next element in the leaf node. A value of -1 </span></div>
<div class="line">    <span class="comment">// indicates the end of the list.</span></div>
<div class="line">    <span class="keywordtype">int</span> next;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores the element index.</span></div>
<div class="line">    <span class="keywordtype">int</span> element;</div>
<div class="line">};</div>
</div><!-- fragment --><p ><b>Possible improvement:</b> Avoid heap allocation (use the stack, whenever possible)</p>
<ul>
<li>e.g. for C++: use &lsquo;SmallList&lt;T&gt;&rsquo; instead of 'vector&lt;T&gt;` for temporary stack of nodes, since no heap allocation is involved (until more than 128 elements are inserted)</li>
</ul>
<h2><a class="anchor" id="autotoc_md173"></a>
Tree representation</h2>
<p ><b>Possible improvement:</b> Elements should be stored in the tree and leaf nodes should index or point to those elements!</p>
<p >Representation of the quadtree itself:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Quadtree</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Stores all the elements in the quadtree.</span></div>
<div class="line">    FreeList&lt;QuadElt&gt; elts;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores all the element nodes in the quadtree.</span></div>
<div class="line">    FreeList&lt;QuadEltNode&gt; elt_nodes;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores all the nodes in the quadtree. The first node in this</span></div>
<div class="line">    <span class="comment">// sequence is always the root.</span></div>
<div class="line">    std::vector&lt;QuadNode&gt; nodes;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores the quadtree extents.</span></div>
<div class="line">    QuadCRect root_rect;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores the first free node in the quadtree to be reclaimed as 4</span></div>
<div class="line">    <span class="comment">// contiguous nodes at once. A value of -1 indicates that the free</span></div>
<div class="line">    <span class="comment">// list is empty, at which point we simply insert 4 nodes to the</span></div>
<div class="line">    <span class="comment">// back of the nodes array.</span></div>
<div class="line">    <span class="keywordtype">int</span> free_node;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Stores the maximum depth allowed for the quadtree.</span></div>
<div class="line">    <span class="keywordtype">int</span> max_depth;</div>
<div class="line">};</div>
</div><!-- fragment --><p >All nodes are stored in contiguously in an array (<code>std::vector&lt;QuadNode&gt;</code>) along with the elements and element nodes (in <code>FreeList&lt;T&gt;</code>).</p>
<h3><a class="anchor" id="autotoc_md174"></a>
FreeList&lt;T&gt;</h3>
<p >A <code>FreeList</code> data structure which is basically an array (and random-access sequence) that lets you remove elements from anywhere in constant-time (leaving holes behind which get reclaimed upon subsequent insertions in constant-time). Here's a simplified version which doesn't bother with handling non-trivial data types (doesn't use placement new or manual destruction calls):</p>
<div class="fragment"><div class="line">/// Provides an indexed free list with constant-time removals from anywhere</div>
<div class="line">/// in the list without invalidating indices. T must be trivially constructible </div>
<div class="line">/// and destructible.</div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">class FreeList</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    /// Creates a new free list.</div>
<div class="line">    FreeList();</div>
<div class="line"> </div>
<div class="line">    /// Inserts an element to the free list and returns an index to it.</div>
<div class="line">    int insert(const T&amp; element);</div>
<div class="line"> </div>
<div class="line">    // Removes the nth element from the free list.</div>
<div class="line">    void erase(int n);</div>
<div class="line"> </div>
<div class="line">    // Removes all elements from the free list.</div>
<div class="line">    void clear();</div>
<div class="line"> </div>
<div class="line">    // Returns the range of valid indices.</div>
<div class="line">    int range() const;</div>
<div class="line"> </div>
<div class="line">    // Returns the nth element.</div>
<div class="line">    T&amp; operator[](int n);</div>
<div class="line"> </div>
<div class="line">    // Returns the nth element.</div>
<div class="line">    const T&amp; operator[](int n) const;</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    union FreeElement</div>
<div class="line">    {</div>
<div class="line">        T element;</div>
<div class="line">        int next;</div>
<div class="line">    };</div>
<div class="line">    std::vector&lt;FreeElement&gt; data;</div>
<div class="line">    int first_free;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">FreeList&lt;T&gt;::FreeList(): first_free(-1)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">int FreeList&lt;T&gt;::insert(const T&amp; element)</div>
<div class="line">{</div>
<div class="line">    if (first_free != -1)</div>
<div class="line">    {</div>
<div class="line">        const int index = first_free;</div>
<div class="line">        first_free = data[first_free].next;</div>
<div class="line">        data[index].element = element;</div>
<div class="line">        return index;</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">    {</div>
<div class="line">        FreeElement fe;</div>
<div class="line">        fe.element = element;</div>
<div class="line">        data.push_back(fe);</div>
<div class="line">        return static_cast&lt;int&gt;(data.size() - 1);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">void FreeList&lt;T&gt;::erase(int n)</div>
<div class="line">{</div>
<div class="line">    data[n].next = first_free;</div>
<div class="line">    first_free = n;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">void FreeList&lt;T&gt;::clear()</div>
<div class="line">{</div>
<div class="line">    data.clear();</div>
<div class="line">    first_free = -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">int FreeList&lt;T&gt;::range() const</div>
<div class="line">{</div>
<div class="line">    return static_cast&lt;int&gt;(data.size());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">T&amp; FreeList&lt;T&gt;::operator[](int n)</div>
<div class="line">{</div>
<div class="line">    return data[n].element;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">template &lt;class T&gt;</div>
<div class="line">const T&amp; FreeList&lt;T&gt;::operator[](int n) const</div>
<div class="line">{</div>
<div class="line">    return data[n].element;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md175"></a>
Maximum tree depth</h3>
<p ><b>Possible improvement:</b> Prevent the tree from subdividing too much</p>
<ul>
<li>specify a maximum depth of the tree</li>
</ul>
<h3><a class="anchor" id="autotoc_md176"></a>
Queries</h3>
<p ><b>Possible improvement:</b> Cache friendly queries</p>
<p >Use:</p>
<div class="fragment"><div class="line">traversed = {}</div>
<div class="line">gather quadtree leaves</div>
<div class="line"><span class="keywordflow">for each</span> leaf in leaves:</div>
<div class="line">{</div>
<div class="line">     <span class="keywordflow">for each</span> element in leaf:</div>
<div class="line">     {</div>
<div class="line">          <span class="keywordflow">if</span> not traversed[element]:</div>
<div class="line">          {</div>
<div class="line">              use quad <a class="code hl_variable" href="namespace_profiler_ids_1_1_time.html#a6bc176ffe75049b4b899b6a019bf15e9">tree</a> <a class="code hl_variable" href="map__sph__to__grid_8c.html#a597496f2fe296b05d07fcafceedb598c">to</a> check <span class="keywordflow">for</span> collision against other elements</div>
<div class="line">              traversed[element] = <span class="keyword">true</span>                  </div>
<div class="line">          }</div>
<div class="line">     }</div>
<div class="line">}</div>
<div class="ttc" id="amap__sph__to__grid_8c_html_a597496f2fe296b05d07fcafceedb598c"><div class="ttname"><a href="map__sph__to__grid_8c.html#a597496f2fe296b05d07fcafceedb598c">to</a></div><div class="ttdeci">struct file to</div></div>
</div><!-- fragment --><p >Instead of:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for each</span> element in scene:</div>
<div class="line">     use quad <a class="code hl_variable" href="namespace_profiler_ids_1_1_time.html#a6bc176ffe75049b4b899b6a019bf15e9">tree</a> <a class="code hl_variable" href="map__sph__to__grid_8c.html#a597496f2fe296b05d07fcafceedb598c">to</a> check <span class="keywordflow">for</span> collision against other elements</div>
</div><!-- fragment --><ul>
<li>it helps make sure that we descend the same paths down the quadtree throughout the loop. That helps keep things much more cache-friendly. Also if after attempting to move the element in the time step, it's still encompassed entirely in that leaf node, we don't even need to work our way back up again from the root (we can just check that one leaf only)</li>
</ul>
<h1><a class="anchor" id="autotoc_md177"></a>
Things to avoid</h1>
<h2><a class="anchor" id="autotoc_md178"></a>
Full-blown containers</h2>
<p >Doing something like</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Node</div>
<div class="line">{</div>
<div class="line">     ...</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Stores the elements in the node.</span></div>
<div class="line">     List&lt;Element&gt; elements; <span class="comment">//e.g. std::vector</span></div>
<div class="line">};</div>
</div><!-- fragment --><p >which allocates and frees it owns memory.</p>
<p >These containers are very efficiently implemented to store a large number of elements, but are extremely inefficient for instantiating a bootload of them to only store a few elements in each one of them, since the containers metadata tends to be quite explosive.</p>
<h1><a class="anchor" id="autotoc_md179"></a>
Loose quadtree</h1>
<p >See <a href="https://stackoverflow.com/questions/41946007/efficient-and-well-explained-implementation-of-a-quadtree-for-2d-collision-det">Stackoverflow</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    milupHPC  - Efficient implementation of a Quadtree (for 2D collision detection)<br />
    Generated on Thu Feb 10 2022 17:28:33 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.9.3
  </small></address>
</body>
<footer>
  <custom-footer color="white" background="#2E4053">
    <div first>first: more content to add</div>
    <div second>second: bla bla bla</div>
    <div third>third: more content to add</div>
  </custom-footer>
</footer>
<!--
<script src="components/side-nav/runtime.js" type="module"></script><script src="components/side-nav/polyfills.js" type="module"></script><script src="components/side-nav/main.js" type="module"></script>
-->
<script src="components/hamburger/runtime.js" type="module"></script><script src="components/hamburger/polyfills.js" type="module"></script><script src="components/hamburger/main.js" type="module"></script>
<script src="components/header/runtime.js" type="module"></script><script src="components/header/polyfills.js" type="module"></script><script src="components/header/main.js" type="module"></script>
<script src="components/icons/runtime.js" type="module"></script><script src="components/icons/polyfills.js" type="module"></script><script src="components/icons/main.js" type="module"></script>
<script src="components/footer/runtime.js" type="module"></script><script src="components/footer/polyfills.js" type="module"></script><script src="components/footer/main.js" type="module"></script>
<script src="components/dialog/runtime.js" type="module"></script><script src="components/dialog/polyfills.js" type="module"></script><script src="components/dialog/main.js" type="module"></script>
<script>
  function toggle() {
    var elem = document.getElementById("side-nav");
    console.log(elem);
    elem.toggleSideNav(false);
  }
</script>
<!--
<script>
  function topFunction() {
    document.body.scrollTop = 0; // For Safari
    document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
  }
</script>
-->
</html>